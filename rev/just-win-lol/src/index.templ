package main

import (
	"fmt"
	"slices"
)

css cardPos(idx int, num string, suit string) {
	background-position: { fmt.Sprintf("-%dpx -%dpx", slices.Index(cards, num) * 142, slices.Index(suits, suit) * 190) };
}

templ indexComponent() {
	<!DOCTYPE html>
	<html>
		<head>
			<script src="https://unpkg.com/htmx.org@1.9.12" integrity="sha384-ujb1lZYygJmzgSwoxRggbCHcjc0rB2XoQrxeTUQyRjrOnlCoYta87iKBWq3EsdM2" crossorigin="anonymous"></script>
			<script>
				document.addEventListener('htmx:afterRequest', function(evt) {
					let cards = document.querySelectorAll(".card");
					cards.forEach((card, idx) => {
						card.style.setProperty("--rotateZ", (idx-cards.length/2) + "deg")
						card.addEventListener("mousemove", (event) => {
							const clampDeg = 15;
							var elemMidX = event.currentTarget.offsetWidth / 2;
							var elemMidY = event.currentTarget.offsetHeight / 2;
							var x = ((event.offsetX - elemMidX) / elemMidX) * clampDeg;
							var y = -1 * (((event.offsetY - elemMidY) / elemMidY) * clampDeg);
					
							card.style.setProperty("--rotateX", y + "deg");
							card.style.setProperty("--rotateY", x + "deg");
							card.style.setProperty("--scale", "1.1");
						});
						card.addEventListener("mouseleave", (event) => {
							card.style.setProperty("--rotateX", "0deg");
							card.style.setProperty("--rotateY", "0deg");
							card.style.setProperty("--scale", "1");
						});
					});
				});
			</script>
			<style>
				body {
    				background-size: cover;
    				background-position: center top;   
					background-image: url("/static/balatrobg.jpg");
					margin: 0;
					padding: 0;
				}
				.wrapper {
					width: 100vw;
					height: 100vh;
					display: grid;
					place-items: center;
				}
				.card {
					--rotateX: 0deg;
					--rotateY: 0deg;
					--rotateZ: 0deg;
					--scale: 1;
					/* use manually nearest neighbor scaled image instead of transform: scale otherwise we
					get blurry images when the 3d transform is applied even with image-rendering: pixelated */
					background-image: url("/static/balatrocards-2x.png");
					background-color: white;
					display: inline-block;
					position: relative;
					width: 142px;
					height: 190px;
					transform: 
						perspective(5000px)
						rotateX(var(--rotateX))
						rotateY(var(--rotateY))
						rotateZ(var(--rotateZ))
						scale(var(--scale));
					transform-style: preserve-3d;
					transition: all 0.1s ease-out;
					margin: -20px;
					image-rendering: pixelated;
					image-rendering: -moz-crisp-edges;
					image-rendering: crisp-edges;
					/* trigger antialiasing for 3d transforms - https://stackoverflow.com/a/27065674 */
					outline: 1px solid transparent;
					box-shadow: 0 0 30px red;
				}
				.card:hover {
					animation: wiggle 0.2s linear 1;
					cursor: pointer;
				}

				@keyframes wiggle {
					0%, 7% {
						transform:
							perspective(5000px)
							rotateX(var(--rotateX))
							rotateY(var(--rotateY))
							rotateZ(var(--rotateZ))
							scale(calc(var(--scale) * 0.9));

					}
					15% {
						transform:
							rotateZ(-6deg)
							perspective(5000px)
							rotateX(var(--rotateX))
							rotateY(var(--rotateY))
							rotateZ(calc(var(--rotateZ) - 6deg))
							scale(calc(var(--scale) * 1.1));
					}
					20% {
						transform:
							perspective(5000px)
							rotateX(var(--rotateX))
							rotateY(var(--rotateY))
							rotateZ(calc(var(--rotateZ) + 4deg))
							scale(calc(var(--scale) * 0.93));
					}
					25% {
						transform:
							rotateZ(-3deg)
							perspective(5000px)
							rotateX(var(--rotateX))
							rotateY(var(--rotateY))
							rotateZ(calc(var(--rotateZ) - 3deg))
							scale(calc(var(--scale) * 1.07));
					}
					30% {
						transform:
							perspective(5000px)
							rotateX(var(--rotateX))
							rotateY(var(--rotateY))
							rotateZ(calc(var(--rotateZ) + 2deg))
							scale(calc(var(--scale) * 0.95));
					}
					35% {
						transform:
							perspective(5000px)
							rotateX(var(--rotateX))
							rotateY(var(--rotateY))
							rotateZ(calc(var(--rotateZ) - 1deg))
							scale(calc(var(--scale) * 1.05));
					}
					40%, 100% {
						transform:
							perspective(5000px)
							rotateX(var(--rotateX))
							rotateY(var(--rotateY))
							rotateZ(var(--rotateZ))
							scale(var(--scale));
					}
				}
				/* from https://codepen.io/meduzen/pen/zxbwRV */
				.scanlines {
					position: relative;
					overflow: hidden;
				}
				.scanlines:before, .scanlines:after {
					display: block;
					pointer-events: none;
					content: "";
					position: absolute;
				}
				.scanlines:before {
					width: 100%;
					height: 2px;
					z-index: 2147483649;
					background: rgba(0, 0, 0, 0.3);
					opacity: 0.3;
				}
				.scanlines:after {
					top: 0;
					right: 0;
					bottom: 0;
					left: 0;
					z-index: 2147483648;
					background: linear-gradient(to bottom, transparent 50%, rgba(100, 100, 100, 0.1) 51%);
					background-size: 100% 4px;
				}

				/* from https://pixelcorners.lukeb.co.uk/?radius=5&multiplier=3&border=1&border_width=1&border_color=#cacfd0 */
				.pixel-corners,
				.pixel-corners--wrapper {
				clip-path: polygon(0px calc(100% - 9px),
					3px calc(100% - 9px),
					3px calc(100% - 6px),
					6px calc(100% - 3px),
					9px calc(100% - 3px),
					9px 100%,
					calc(100% - 9px) 100%,
					calc(100% - 9px) calc(100% - 3px),
					calc(100% - 6px) calc(100% - 3px),
					calc(100% - 3px) calc(100% - 6px),
					calc(100% - 3px) calc(100% - 9px),
					100% calc(100% - 9px),
					100% 9px,
					calc(100% - 3px) 9px,
					calc(100% - 3px) 6px,
					calc(100% - 6px) 3px,
					calc(100% - 9px) 3px,
					calc(100% - 9px) 0px,
					9px 0px,
					9px 3px,
					6px 3px,
					3px 6px,
					3px 9px,
					0px 9px);
				position: relative;
				}
				.pixel-corners {
				border: 3px solid transparent;
				}
				.pixel-corners--wrapper {
				width: fit-content;
				height: fit-content;
				}
				.pixel-corners--wrapper .pixel-corners {
				display: block;
				clip-path: polygon(3px 9px,
					6px 9px,
					6px 6px,
					9px 6px,
					9px 3px,
					calc(100% - 9px) 3px,
					calc(100% - 9px) 6px,
					calc(100% - 6px) 6px,
					calc(100% - 6px) 9px,
					calc(100% - 3px) 9px,
					calc(100% - 3px) calc(100% - 9px),
					calc(100% - 6px) calc(100% - 9px),
					calc(100% - 6px) calc(100% - 6px),
					calc(100% - 9px) calc(100% - 6px),
					calc(100% - 9px) calc(100% - 3px),
					9px calc(100% - 3px),
					9px calc(100% - 6px),
					6px calc(100% - 6px),
					6px calc(100% - 9px),
					3px calc(100% - 9px));
				}
				.pixel-corners::after,
				.pixel-corners--wrapper::after {
				content: "";
				position: absolute;
				clip-path: polygon(0px calc(100% - 9px),
					3px calc(100% - 9px),
					3px calc(100% - 6px),
					6px calc(100% - 3px),
					9px calc(100% - 3px),
					9px 100%,
					calc(100% - 9px) 100%,
					calc(100% - 9px) calc(100% - 3px),
					calc(100% - 6px) calc(100% - 3px),
					calc(100% - 3px) calc(100% - 6px),
					calc(100% - 3px) calc(100% - 9px),
					100% calc(100% - 9px),
					100% 9px,
					calc(100% - 3px) 9px,
					calc(100% - 3px) 6px,
					calc(100% - 6px) 3px,
					calc(100% - 9px) 3px,
					calc(100% - 9px) 0px,
					9px 0px,
					9px 3px,
					6px 3px,
					3px 6px,
					3px 9px,
					0px 9px,
					0px 50%,
					3px 50%,
					3px 9px,
					6px 9px,
					6px 6px,
					9px 6px,
					9px 3px,
					calc(100% - 9px) 3px,
					calc(100% - 9px) 6px,
					calc(100% - 6px) 6px,
					calc(100% - 6px) 9px,
					calc(100% - 3px) 9px,
					calc(100% - 3px) calc(100% - 9px),
					calc(100% - 6px) calc(100% - 9px),
					calc(100% - 6px) calc(100% - 6px),
					calc(100% - 9px) calc(100% - 6px),
					calc(100% - 9px) calc(100% - 3px),
					9px calc(100% - 3px),
					9px calc(100% - 6px),
					6px calc(100% - 6px),
					6px calc(100% - 9px),
					3px calc(100% - 9px),
					3px 50%,
					0px 50%);
				top: 0;
				bottom: 0;
				left: 0;
				right: 0;
				background: #cacfd0;
				display: block;
				pointer-events: none;
				}
				.pixel-corners::after {
				margin: -3px;
				}
			</style>
		</head>
		<body class="scanlines">
			<div class="wrapper">
				<div class="hand"></div>
				<button
				hx-get="/hand"
				hx-trigger="click"
				hx-target=".hand"
				hx-swap="innerHTML">
					get hand
				</button>
			</div>
		</body>
	</html>
}

templ handComponent(hand []string) {
	for idx, card := range hand {
		// add easy to read class name instead of autogenerated one
		<div class={ "card", "pixel-corners", cardPos(idx, card, "c") }></div>
	}
}